# 你不知道JS：异步

# 第四章：生成器（Generators）

在第二章，我们明确了采用回调表示异步流的两个关键缺点：

+ 基于回调的异步和我们大脑按步规划任务的方式不相吻合。
+ 由于*控制权反转*，回调不可信且无法组合。

在第三章中，我们详细描述了Promise如何反逆转回调的*控制权反转*问题的，是我们重新获得了可信任/可组合的能力。

现在，我们把目光转向一种序列化的、看起来像同步的异步流表示形式。实现这一功能的“魔法”是ES6 **生成器**。

## 打破运行直至结束（Breaking Run-to-Completion）

在第一章，我们解释了一个JS开发者在代码中普遍依赖的期望：一旦函数开始执行，它会一直运行到结束，在此之间没有其它代码（译者注：不包括其中的错误代码哈）能够中断和执行。

尽管看起来有点奇怪，ES6引入了一个新的函数类型，它的行为不同于Run-to-Completion。这种新类型的函数称为“生成器”。

为理解其含义，让我们考虑下这个例子：

```javascript
var x = 1;

function foo() {
    x++;
    bar();              // <-- what about this line?
    console.log( "x:", x );
}

function bar() {
    x++;
}

foo();                  // x: 3
```

在这个例子中，我们很确定`bar()`会在`x++`和`console.log(x)`之间运行。但要是`bar()`不在那呢？很显然，结果是`2`，而不是`3`。

让我们动动你的脑筋。要是`bar()`语句不存在，但是由于某种原因，仍然在`x++`和`console.log(x)`语句之间运行？怎么可能？

在**抢占式**多线程语言中，`bar()`中断这两个语句（译者注：指`x++`和`console.log(x)`语句）并且就在两者之间执行是可能的。但JS不是抢占式的，也不是（目前）多线程的。另外，如果`foo()`本身在代码的某个部分可以“暂停”，则这种“中断”（并发）的**合作**（cooperative）形式是可能的。

**注意：** 我使用了“合作”（cooperative）一词，不仅仅是因为和传统的并发术语的联系（见第一章），还因为ES6语法中指明代码暂停点的`yield`--