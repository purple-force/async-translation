# 你不知道JS：异步

# 第四章：生成器（Generators）

在第二章，我们明确了采用回调表示异步流的两个关键缺点：

+ 基于回调的异步和我们大脑按步规划任务的方式不相吻合。
+ 由于*控制权反转*，回调不可信且无法组合。

在第三章中，我们详细描述了Promise如何反逆转回调的*控制权反转*问题的，是我们重新获得了可信任/可组合的能力。

现在，我们把目光转向一种序列化的、看起来像同步的异步流表示形式。实现这一功能的“魔法”是ES6 **生成器**。

## 打破运行直至结束（Breaking Run-to-Completion）

在第一章，我们解释了一个JS开发者在代码中普遍依赖的期望：一旦函数开始执行，它会一直运行到结束，在此之间没有其它代码（译者注：不包括其中的错误代码哈）能够中断和执行。

尽管看起来有点奇怪，ES6引入了一个新的函数类型，它的行为不同于Run-to-Completion。这种新类型的函数称为“生成器”。

为理解其含义，让我们考虑下这个例子：

```javascript
var x = 1;

function foo() {
    x++;
    bar();              // <-- what about this line?
    console.log( "x:", x );
}

function bar() {
    x++;
}

foo();                  // x: 3
```

在这个例子中，我们很确定`bar()`会在`x++`和`console.log(x)`之间运行。但要是`bar()`不在那呢？很显然，结果是`2`，而不是`3`。

让我们动动你的脑筋。要是`bar()`语句不存在，但是由于某种原因，仍然在`x++`和`console.log(x)`语句之间运行？怎么可能？

在**抢占式**多线程语言中，`bar()`中断这两个语句（译者注：指`x++`和`console.log(x)`语句）并且就在两者之间执行是可能的。但JS不是抢占式的，也不是（目前）多线程的。另外，如果`foo()`本身在代码的某个部分可以“暂停”，则这种“中断”（并发）的**协作**（cooperative）形式是可能的。

**注意：** 我使用了“协作”（cooperative）一词，不仅仅是因为和传统的并发术语的联系（见第一章），还因为ES6语法中采用`yield`指明代码中的暂停点--表示一个礼貌性地*协作式*控制让步。

以下是实现此类协作并发的ES6代码：

```javascript
var x = 1;

function *foo() {
    x++;
    yield; // pause!
    console.log( "x:", x );
}

function bar() {
    x++;
}
```

**注意：**你可能看到绝大多数其它JS文档/代码会以`function* foo() { .. }`的形式声明一个生成器，而不是我此处使用的`function *foo() { .. }`--唯一的不同是`*`的文体位置。这两种格式从功能/语法上来说是一致的，和第三种形式，`function*foo() { .. }`（没有空格）也是一样的。这两种形式都有争议，但是我偏向于`function *foo..`，因为这与我以`*foo()`形式引用生成器的方式相吻合。如果我只说`foo()`，你不知道我是在说生成器还是一个普通的函数。完全是文体形式上的偏爱而已。

现在，我们该如何运行前面的代码，使得`bar()`运行到`*foo()`中的`yield`点？

```javascript
// construct an iterator `it` to control the generator
var it = foo();

// start `foo()` here!
it.next();
x;                      // 2
bar();
x;                      // 3
it.next();              // x: 3
```

好，这两段代码中有些新的并且有些令人困惑的东西，因此我们需要了解的更多才行。但在我们解释ES6生成器的不同机制/语法之前，让我们简单过下代码的行为流程：

1. `it = foo()`操作还*没有*执行`*foo()`生成器（译者注：指内部的代码），而是仅仅构建了控制执行的*迭代器（iterator）*。关于*迭代器*的更多细节会在后面提及。
2. 第一个`it.next()`启动了`*foo()`生成器，执行了`*foo()`中第一行的`x++`。
3. `*foo()`在`yield`语句处暂停，即第一个`it.next()`调用结束的点。此时`*foo()`仍然在运行并活动，只是处在暂停状态。
4. 我们检查了`x`的值，现在是`2`。
5. 我们调用`bar()`，通过`x++`又增加了`x`的值。
6. 我们再次检查`x`的值，现在是`3`。
7. 最后的`it.next()`调用从暂停的地方恢复了`*foo()`生成器，运行`console.log(..)`语句，使用当前`x`的值`3`。

很明显，`*foo()`启动时，并*没有*运行直至结束（run-to-completion）--它在`yield`处暂停。我们随后恢复了`*foo()`，让它结束，但那并不是必须的。

因此，生成器是一种特殊类型的函数，可以启动和停止一次或多次，甚至没必要结束。尽管它为什么如此强大还不是很明显，随着我们深入本章的其它部分，我们会发现，它会是用来构建生成器异步流控制（generators-as-async-flow-control）模式的重要构建块之一。