## 你不知道JS：异步

## 第一章：异步：现在&以后

在像JavaScript这种编程语言中，最重要也是常被误解的的一点是如何表示和控制程序的行为，使它扩展到一段时间内。

这并不只是从`for`循环开始到`for`循环结束所发生的那么简单，当然，它会花费一定的时间（几微秒到几毫秒）。我们关注的是当你的部分程序现在运行，而另一部分之后运行时所发生的事情--在 *现在* 和 *以后* （对应的程序并不是主动执行的）之间有个界限。

日常开发中，所有写过的优秀程序（尤其是在JS中）都或多或少地需要管理这个界限，不论是等待用户输入、从数据库或文件系统请求数据、跨网络发送数据和等待响应，还是定期执行一个重复任务（比如动画）。在所有这些场景当中，你都得及时地在界限间管理状态。正如伦敦地铁著名的那句：小心间隙（mind the gap）。

事实上，程序中的 *现在* 和 *以后* 的关系是异步编程的核心。

可以确认的一点是，自出现JS，异步编程就一直贯穿始终。但绝大多数JS开发者没有认真考虑过，他们的程序中是怎么以及为什么突然出现异步的，或者研究过如何用其它方法实现它。回调函数一直都是足够好的方法。至今仍有许多人坚持认为回调函数已经足够了。

但是，为了满足作为运行在浏览器端和服务端以及每个想象的到的设备中的第一等语言的广泛的需求，JS在范围和复杂度上面都在不断增长，我们管理异步的痛苦与日俱增。所以需要寻求一种功能更好、更合理的方法。

尽管目前看起来十分抽象，随着不断深入这本书，我向你们保证我们能够更完整和彻底地处理异步。在之后几章中，我们会探索JS中出现的各种异步编程技术。

但在开始之前，我们必须深刻理解下什么是异步，以及如何在JS中实现。

### 块状形式的程序

你可能在一个`.js`的文件中写JS程序，但是你的程序绝大多数是由几块组成的，只有一个是 *现在* 执行的，其余的是 *以后* 执行的。最常见的块单元是`function`。

绝大多数JS新手遇到的问题是认为 *以后* 不是严格地在 *现在* 之后立即发生的。换句话说，从定义上讲，不能 *现在* 完成的任务将会异步完成，因此不会出现你直观上期望或想要的阻塞行为。

考虑如下代码：


```javascript
// ajax(..) is some arbitrary Ajax function given by a library
var data = ajax( "http://some.url.1" );

console.log( data );
// Oops! `data` generally won't have the Ajax results
```
你也许注意到了标准的Ajax请求并不是同步的，这意味着`ajax(...)`还没有返回值用来赋给`data`变量。如果`ajax(...)`能够阻塞程序直到返回响应，则`data=...`赋值操作能够正常运行。

但这不是我们运用Ajax的方式。我们 *现在* 作了一个异步的Ajax请求，直到 *以后* 才获得结果。

最简单的（但显然不是唯一，更不是最好的）的从 *现在* 等直到 *以后* 的方法是采用一个函数，通常称为回调函数：

```javascript
// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", function myCallbackFunction(data){

    console.log( data ); // Yay, I gots me some `data`!

} );
```
**警告：** 你可能听说过可以使用同步Ajax请求。尽管技术上是可行的，但是在任何情况下绝对不要使用。因为它会锁死浏览器UI（按钮、菜单、滚动等），并且会阻止任何用户交互。这是个很糟糕的想法，应极力避免。

在你抗议争论之前，你所期望的避免回调混乱不是为同步Ajax造成的阻塞辩护。

例如，考虑以下代码：

```javascript
function now() {
    return 21;
}

function later() {
    answer = answer * 2;
    console.log( "Meaning of life:", answer );
}

var answer = now();

setTimeout( later, 1000 ); // Meaning of life: 42
```
这段程序有两大块(chunk)，一块是 *现在* 执行的，另一块是 *以后* 执行的。这两块应该很清楚就能看出来，让我们明确解释一下：

*现在*：

```javascript
function now() {
    return 21;
}

function later() { .. }

var answer = now();

setTimeout( later, 1000 );
```

*以后*：

```javascript
answer = answer * 2;
console.log( "Meaning of life:", answer );
```
只要你执行程序，*现在*块立即运行。但是`setTimeout(...)`也设置了一个事件（一个超时），用来*以后*执行，因此`later()`函数的内容会在之后的一个时间执行（从现在起1000毫秒后）.

任何时候把一段代码包裹到`function`，并指定到对应事件（定时器、鼠标单击、Ajax请求等）执行，你就创建了一个*以后*代码块，从而在程序中引入异步。

### 异步 Console

没有规范或要求定义`console.*`方法是如何运行的--它们并不是JavaScript的官方部分，而是主机环境（译者注：如浏览器，服务端等）加入到JS当中的。

因此，不同的浏览器和JS环境随意实现，有时可能会导致令人困惑的行为。

尤其是有些浏览器和环境中，`console.log(...)`并不会立即输出给定的值。主要原因可能是I/O在许多程序中（不仅仅是JS）是一个非常缓慢和阻塞性的部分。因此，对浏览器来说，在后台异步处理`console`I/O可能性能更好（从页面/UI角度），你甚至不知道它的发生。

尽管不太常见，但可能看到这个场景（不是从代码层面，而是从外部（译者注：执行结果））：

```javascript
var a = {
    index: 1
};

// later
console.log( a ); // ??

// even later
a.index++;
```

我们通常认为`a`对象在`console.log(...)`语句执行时是个快照，输出比如`{index:1}`，以至于当`a.index++`执行的时候，只是严格地在输出   之后修改`a`。

大多数时候，前面的代码在你的开发工具中的控制台能够产生你期望的结果。但同样的代码也可能在觉得需要推迟`console`I/O到后台的浏览器中运行，那样的话，在浏览器控制台中，显示出`a`的时候，`a.index++`可能已经执行了，从而输出`{index:2}`。

到底在什么情况下`console`I/O会被推迟执行，或者是否能观测到这一现象是不确定的。记住，每当你调试一个在`console.log(...)`语句后修改对象的代码时，注意可能的异步I/O，你可能看到不可思议的结果出现。

**注意：** 如果你碰到这种很少见的情况，最好的选择时采用JS调试器的断点，而不是依赖`console`输出。另一个较好的方法是将查询的对象序列化为字符串，比如`JSON.stringify(...)`。

### 事件轮询

让我们小小抱怨一下：尽管允许异步JS代码（正如我们刚刚看到的timeout一样），直到最近（ES6），JS本身从来没有内建的直接表示异步的概念。

**纳尼!?**似乎很疯狂对不对，事实上是真的。当被要求的时候，JS引擎除了在任何给定时刻执行程序中的单个代码块以外，什么都没做。

"谁要求的？"这是关键所在！

JS引擎并不是孤立运行的，它处在主机环境中，对绝大多数开发者来说是普通的web浏览器。在过去的几年里，JS已经从浏览器扩展到其它环境，比如服务端，通过Node.js。事实上，如今JS已经被嵌入到各种设备当中，从机器人到灯泡。

但在所有这些环境中，有一个通用的“线程”，采用该机制按时间来处理执行多个代码块，在每个时刻激活JS引擎，这称作“事件轮询”。

换句话说，JS引擎天生就没有时间的概念，但是有对任何JS代码片段按需执行的环境。正是这个环境调度“事件”（JS代码执行）。

因此，比如当你的JS代码发出了一个Ajax请求从服务端获取数据，你在一个函数（通常称为“回调”）中设置了一个“响应”代码，然后JS引擎告诉主机环境，“嗨，我现在准备中止执行了，但是当你完成网络请求，并且有数据了，请调用后面的这个函数”。

然后浏览器对这个网络响应设置监听，当有东西返回的时候，浏览器通过把回调函数插入事件轮询执行回调。

那么事件轮询是什么？

让我们通过一些伪代码将它概念化：

```javascript
// `eventLoop` is an array that acts as a queue (first-in, first-out)
var eventLoop = [ ];
var event;

// keep going "forever"
while (true) {
    // perform a "tick"
    if (eventLoop.length > 0) {
        // get the next event in the queue
        event = eventLoop.shift();

        // now, execute the next event
        try {
            event();
        }
        catch (err) {
            reportError(err);
        }
    }
}
```

当然，这只是用来说明这一概念的简化的伪代码，但是帮助我们理解的话，已经足够了。

如你所见，有一个如`while`循环所示的一个持续运行的循环，每次循环遍历称为一个“tick”。对每个tick来说，如果队列中有一个事件正在等待，则离开队列立即执行。这些事件就是你的回调函数。

需要注意的一点是，`setTimeout(...)`并不会把你的回调函数放入事件轮询队列，它干的只是设置一个定时器，当定时器过期时，主机环境把你的回调函数放入事件轮询，这样某个未来的tick就会拾起并执行这个回调函数。

假如那时事件队列中已经有20项了呢？你的回调函数得等，排队站在其它的后面。通常没有办法抢占队列以跳到队列前头。这就解释了为什么`setTimeout(...)`定时器可能没恰好在设定的时间触发。（通常来说）执行环境能够确保你的回调不会在你设定的时间前触发，但是可能在你设定的或者之后的时间触发，依事件队列的状态而定。

因此，换句话说，你的程序通常被分为几小块，在事件队列中一个接着一个的执行。从技术上讲，和你的程序没有直接关系的事件也能够在队列中插入。

**注意：** 我们之前提到的ES6改变了事件轮询队列的管理方法。它是一个正式的术语，但ES6指定了事件队列如何运行，从技术角度讲，它被纳入了JS引擎的范畴，而不仅仅是主机环境。这一改变的主要原因是ES6 Promises的引入，我们会在第三章讨论。因为他们需要能够对事件轮询队列的调度作直接、精细地控制（可见“协作”小节中`setTimeout(...0)`的讨论）

### 多线程

把“异步”和“并行”理解为一个东西的想法很常见，但它们其实一点都不同。记住，异步是关于*现在* 和 *以后* 的界限。但并行是允许事情能够同时发生。

最常用的并行计算工具是多进程和多线程。多进程和多线程可以独立并且可能同时运行：单独的处理器或者单独的电脑，但多线程可共享单个进程的内存。

相反，事件轮询把工作分为多个任务并按序执行，不允许对共享内存的并行访问和修改。并行化和“序列化”可以在不同的线程中以协作的事件轮询形式共存。

多线程执行的插入和异步事件的插入发生的粒度不同。

例如：

```javascript
function later() {
    answer = answer * 2;
    console.log( "Meaning of life:", answer );
}
```

尽管`later()`的内容被视作单个事件轮询入口，当考虑到这段代码执行所在的线程时，事实上可能有许多低等级的操作。比如，`answer = answer * 2`需要首先加载`answer`的当前值，然后把`2`放在某个地方，然后执行乘法操作，获得结果并把它存回`answer`变量中。

在单线程环境中，线程队列中的任务项是低等级操作并不重要，因为无法中断线程。但如果是在并行系统中，两个不同的线程运行同一个程序，你可能得到预料不到的结果。

考虑如下代码：

```javascript
var a = 20;

function foo() {
    a = a + 1;
}

function bar() {
    a = a * 2;
}

// ajax(..) is some arbitrary Ajax function given by a library
ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

在JS单线程下，如果`foo()`在`bar()`之前运行，结果就是`a`为42，但是如果`bar()`在`foo()`之前运行，则`a`为41。

然而，如果共享相同数据的JS事件并行执行，问题可能更难以捉摸。考虑如下两个伪代码任务，两个线程可以各自运行`foo()`和`bar()`代码，如果它们同时运行，考虑下会发生什么：

线程1:（`x`和`y`是临时内存位置）

```javascript
foo():
  a. load value of `a` in `X`
  b. store `1` in `Y`
  c. add `X` and `Y`, store result in `X`
  d. store value of `X` in `a`
```

线程2:（`x`和`y`是临时内存位置）

```javascript
bar():
  a. load value of `a` in `X`
  b. store `2` in `Y`
  c. multiply `X` and `Y`, store result in `X`
  d. store value of `X` in `a`
```

现在，我们假设两个线程是真正并行运行的。你可能注意到问题了，是吧？它们在临时步骤中使用了共享内存位置`x`和`y`。

如果按如下步骤执行下来，`a`是多少？

```javascript
1a  (load value of `a` in `X`   ==> `20`)
2a  (load value of `a` in `X`   ==> `20`)
1b  (store `1` in `Y`   ==> `1`)
2b  (store `2` in `Y`   ==> `2`)
1c  (add `X` and `Y`, store result in `X`   ==> `22`)
1d  (store value of `X` in `a`   ==> `22`)
2c  (multiply `X` and `Y`, store result in `X`   ==> `44`)
2d  (store value of `X` in `a`   ==> `44`)
```

结果`a`为`44`，但是这个顺序呢？

```javascript
1a  (load value of `a` in `X`   ==> `20`)
2a  (load value of `a` in `X`   ==> `20`)
2b  (store `2` in `Y`   ==> `2`)
1b  (store `1` in `Y`   ==> `1`)
2c  (multiply `X` and `Y`, store result in `X`   ==> `20`)
1c  (add `X` and `Y`, store result in `X`   ==> `21`)
1d  (store value of `X` in `a`   ==> `21`)
2d  (store value of `X` in `a`   ==> `21`)
```
最终`a`为`21`。

因此，线程编程非常具有欺骗性。如果你不采取特别措施来阻止这种相互干扰/插入，可能会得到非常奇怪并且不确定的结果，着实让人头疼。

JS从来不在线程间共享数据，这意味着不确定性不是大问题。但那并不是说JS总是确定性的。记得早些时候的`foo()`和`bar()`的相对顺序导致的不同结果吗(`41`还是`42`)？

**注意：** 尽管不明显，但并不是所有的不确定性都是坏的。有时是不相关的，有时是特意的。在下文以及后面几章中，我们会看到更多示例。

### 运行直至结束（Run-to-Completion）

因为JS是单线程的，`foo()`（和`bar()`）中的代码是原子性的，意思是一旦`foo()`开始运行，它的所有代码将会在`bar()`中任何代码执行前执行完，反之亦是如此。这就叫做“运行直至结束”。

事实上，如果`foo()`和`bar()`的内部有更多代码时，run-to-completion语义更明显，比如：

