## 你不知道JS：异步

## 第二章：回调（Callbacks）

在第一章中，我们探究了JS中异步编程方面的一些术语和概念。我们的重点在于理解这一概念，即单线程（一次一个）事件轮询队列驱动着所有的”事件“（异步函数调用）。我们也探究了用并发模式来解释同时运行的事件链之间或者”进程“（任务，函数调用等）之间关系（如果有的话）的各种方式。

第一章中的所有例子采用的函数都是单独的、不可分割的操作单元，从而在函数内部，语句都是按照可预测的顺序运行的（高于编译器级）,但在函数顺序级，事件（即异步函数调用）可能以各种顺序运行。

在所有这些情形当中，函数充当了”回调“的角色，因为当处理队列中的某项任务时，它用于将事件轮询”回调入“程序当中。

毫无疑问，你已经注意到了，回调是迄今为止JS中表示和管理异步最普遍的方式了。诚然，回调是该语言中最重要的异步模式。

无数的JS程序，甚至是非常复杂的程序，它们的异步都是建立在回调基础上的，别无其它（当然也包括我们在第一章中所探究的并发交互模式）。回调函数是JS异步的驮马（译者注：意指绝大多数的异步是通过回调实现的），并且它做的还不错。

除了...回调函数也并不是没有缺点。很多开发者对更好的异步模式promise（双关，译者注：既指承诺，又指ES6中引入的Promise异步）感到十分激动。
但如果你不理解它抽象的是什么，以及为什么这样，就不可能有效地使用任何抽象。（译者注：好抽象！！！）

本章中，我们会深入探究下这些东西，以促使我们研究为什么更复杂的异步模式很有必要以及更受期待。

### 续集（Continuations）

让我们回到第一章中开始时的异步回调的例子，但为了说明一点，让我稍微修改一下：

```javascript
// A
ajax( "..", function(..){
    // C
} );
// B
```

`// A`和`// B`代表程序的第一部分（即*现在*），`// C`代表程序中的第二部分（即*以后*）。第一个部分立即执行，然后有一个不确定时间的”暂停“。在未来的某个时候，如果Ajax调用完成，程序会从停下的地方开始，继续第二部分。

换句话说，回调函数封装了程序的*续集*。

让我们再简化下代码：

```javascript
// A
setTimeout( function(){
    // C
}, 1000 );
// B
```

等一下，问问自己该如何（向其他对JS如何运作知之甚少的人）描述程序的运行方式。继续，大声点。这是一次很好的尝试，会让我接下来的观点更有意义。

绝大多数读者目前的想法也只能达到这种程度：”执行A，然后设置一个1000毫秒的定时器，之后一旦触发，执行C“。你的解释有多接近？

你可能发现自己又修改成：”执行A，设置个1000毫秒的定时器，之后执行B，然后待定时器触发，执行C“。这比第一版更精确，你能注意到其中的差异吗?

即使第二版更精确，这两个版本都不足以以想法匹配代码、代码匹配JS引擎的方式解释这段代码。这种断层既微妙又意义重大，是理解作为表达和管理异步的回调的缺点的核心。

一旦我们以回调函数的形式引入一个续集（或者如许多程序那样引入好几个），就会在脑中所想的和代码运行的方式之间产生分歧。任何时候，这两个的分歧都会不可避免地让我们的代码更难以理解，推论，调试和维护。

### 序列化的大脑（Sequential Brain）

我很确定绝大多数读者曾经听过某人说（甚至你也说过），”我是个一心多用的人“（译者注：指能同时处理多个任务）。从幽默的（比如，愚蠢的边拍脑袋边揉肚子的孩子游戏）到平常的（边走边嚼口香糖），再到非常危险的（边开车边发短信），形如这些种种。

但我们是一心多用的人吗？我们真的可以同时做并思考两件有意识的事情吗？我们大脑的最高等级的功能中有并行多线程在运行吗？

答案可能让你感到惊讶：**或许不是**。

我们的大脑并不是那样设定的。尽管许多人（尤其是A类型人格的人）不愿承认，我们是一心一用的人。我们在任一时刻只能想一件事情。

我不是要讨论所有无意识的、潜意识的、自动的大脑功能，比如心跳、呼吸和眨眼睛等。这些都是维持生命所必须的重要任务，但我们不会特意分配脑力到这些事情上。谢天谢地，就算我们在三分钟内查看了15次社交网络提示，我们的大脑也会在幕后（多线程）处理所有这些重要的任务。

我们关注的反而是此刻幕前心里在处理什么任务。对我而言，我正在写这本书。此时此刻我还做着其它更高级的脑部功能吗？不，并没有。我很快并且很容易分心--最近几段文字已经分心好几次了！

当我们假装多任务时，比如在和朋友或者家人打电话时打字，我们所做的其实是在尽可能快地在多个情境中来回切换。换句话说，我们在两个或更多的任务之间持续的快速切换，处理很短很小的任务块。这一过程如此之快，以至于从外面看来，我们好像在并行地做这些事情。

对你而言，听起来是不是怀疑有点像异步事件并发（就跟JS中发生的差不多）？如果不是，回去重读第一章！

事实上，一种将复杂的神经世界简化为我想在此讨论的东西的方式是我们的大脑就像是事件轮询队列。

如果你把我写的每个字母（或者单词）想象是一个异步事件，对我而言，就在这一句话里，我的大脑思维就有可能多次被其它事件打断，比如我自己的感觉，亦或者其它随机的想法。

但每次我都不会被打断并拉到另一个”进程“当中去（谢天谢地--要不然就不会写这本书了）。但我经常感觉到我的大脑在各种不同的情境（即”进程“）间不断切换。如果JS引擎有感觉的话，它也会感到很痛苦。

###执行 VS 计划（Doing Versus Planning）

好，我们可以将大脑想像为以单线程事件轮询队列的方式运行的，就像JS引擎一样。听起来挺搭的。

但我们需要更细致地分析其中的微妙差异。在如何规划各种任务和如何执行任务之间，有个巨大的、可见的差异。

再拿我写文章的比喻来说，我粗略的罗列了下计划，按照心中想到的点按顺序一直写一直写。在写作过程中，我并没有计划遇到任何中断或者非线性的活动（译者注：指跟写作无关的东西）。然而，我的大脑一直在切换。

即使从操作层面来说，我的大脑是异步事件的，我们似乎喜欢以同步、序列化的方式规划任务。”我要去商店，然后买一些牛奶，然后把衣物交给干洗店“

你可能注意到，这种高层级的想法（计划）从形式上来看并不是异步事件的。实际上，单独按照事件来想对我们而言很少见。反而，我们序列化地规划事情（A然后B然后C），就好像有某种时间阻塞强制B等A，C等B一样。

当开发人员写代码时，他们规划了一系列将要发生的事情。如果他们是优秀的开发人员，他们会仔细规划。”我要把`z`设为`x`的值，然后把`x`设为`y`的值“等等。

当我们一句一句地写出同步代码时，大概是这个样子：

```javascript
// swap `x` and `y` (via temp variable `z`)
z = x;
x = y;
y = z;
```

这三个赋值语句时同步的，因此`x=y`等`z=x`结束，而`y=z`等`x=y`结束。换句话说，这三个语句应该按照一个特定顺序执行，一个接着一个。万幸的是，这儿，我们不需要面对恼人的异步事件细节。如果需要的话，代码立刻会变得很复杂。

因此，如果同步的思维方式能够很好的映射到同步的代码语句，那么我们的大脑在规划异步代码时能做得有多好呢？


事实证明，我们代码表达异步（用回调）的方式并不能很好的符合我们大脑的同步规划事情这一行为。

你能像这样按时间线实际想象下计划的待做事件吗？

> "我要去趟商店，但路上我会打个电话，那么’嗨，妈妈‘，在她说话的时候，我会在GPS上查询商店的地址，但是会花几分钟加载，之后我调低收音机的音量，以便于我能够听清楚妈妈说话，然后我意识到我忘了穿夹克，外面挺冷的，但没关系，一直开，并且和妈妈打电话。之后听到叮的一声，提醒我系紧安全带，’是的，妈妈，我正在系安全带，我一直都系的‘，啊哈，最终GPS找到的正确的方向，现在..."

尽管在日常生活中，以这种方式规划、思考做什么以及做的顺序，听起来有点可笑，然而这正是我们大脑运行的方式。记住，这不是多任务，仅仅是快速切换。

对于开发人员来说，写异步事件代码，尤其是都是采用回调实现的话，是很困难的。究其原因，是因为意识流式的思考/计划不符合我们绝大多数人的本性。

我们是按照一步一步的顺序来想事情的，一旦我们从同步转向异步的时候，代码中可用的工具（回调）不是按照一步一步的方式表达的。

这就是为什么很难用回调准确地编写和解释异步代码：因为不是我们大脑思考问题的方式。

**注意：** 

唯一一件比不知道代码为什么异常更糟的事情是不知道为什么刚开始的时候好好的！这是经典的”纸牌屋“心理：”它运行正常，但不知道为什么，因而也就没人去碰它了！“你可能听说过，”他人即是地狱“（萨特），编程人员稍微改动一下，”他人的代码就是地狱“。我真的认为：”不了解自己的代码才是地狱“。而回调则是罪魁祸首。

### 嵌套/链式回调（Nested/Chained Callbacks）

考虑如下代码：

```javascript
listen( "click", function handler(evt){
    setTimeout( function request(){
        ajax( "http://some.url.1", function response(text){
            if (text == "hello") {
                handler();
            }
            else if (text == "world") {
                request();
            }
        } );
    }, 500) ;
} );
```

像这样的代码你一定很熟悉，我们用三个函数嵌套在一起，每一个代表一个异步操作（任务，”进程“）。

这种代码常称为”回调地狱“（callback hell），有时也成为”末日金字塔“（pyramid of doom）（因为由于嵌套缩进，看起来像一边倾斜的三角形）。

但是”回调地狱“和嵌套/缩进几乎没什么关系。问题远不止如此。随着深入本章的其余部分，我们会明白其中的道理。

首先，我们等待”click“事件，之后等待定时器触发，之后再等待AJax响应返回，此时可能从头再来一遍。

第一眼看上去，这段代码似乎很自然地将异步映射到序列化的大脑计划方式上去。

首先（*现在*）,我们：

```javascript
listen( "..", function handler(..){
    // ..
} );
```

*之后*，我们：

```javascript
setTimeout( function request(..){
    // ..
}, 500) ;
```

再*之后*，我们：

```javascript
ajax( "..", function response(..){
    // ..
} );
```

最终（再*之后*），我们：

```javascript
if ( .. ) {
    // ..
}
else ..
```

但以这种线性方式解释这段代码有些问题。

首先，很巧合，我们的示例代码是一步一步来的（1,2,3,4...）。在实际的异步JS编程中，通常有许多干扰项出现，使得我们在从一个函数跳到另一个函数的时候，需要在脑中灵巧地绕过这些干扰项。在这种回调负担下理解异步流不是不可能，但即使有过多次实践，也不会是一件很自然和容易的事。

另外，还有一些更深层次的问题，这在实例代码中并不明显。让我们举另一个例子（伪代码）来说明：

```javascript
doA( function(){
    doB();

    doC( function(){
        doD();
    } )

    doE();
} );

doF();
```

尽管有经验的人能够正确地识别运行的顺序，我打赌第一眼看上去的时候还是有点困惑的，可能在心里想会儿才行。代码将会按以下顺序运行：

+ `doA()`
+ `doF()`
+ `doB()`
+ `doC()`
+ `doE()`
+ `doD()`

你第一次看到代码时做对了吗？

好，有些人会想我的函数命名并不公平，故意把人引入迷途。我发誓我只是按照从上到下的方式按序命名的。那我们再试一次：

```javascript
doA( function(){
    doC();

    doD( function(){
        doF();
    } )

    doE();
} );

doB();
```

现在，我们已经按照实际执行的字母顺序重命名了。但我打赌即使对这个情形有经验了，对多数读者来说，通过跟踪`A -> B -> C -> D -> E -> F`的顺序并不自然。同样，你的眼睛在代码片段之间痛苦地跳来跳去，是吗？

但即使你认为看起来还算自然，仍然有个巫师可能捣乱，你注意到是什么了吗？

假如`doA(..)`或`doD(..)`不是我们认为的异步的呢？哦，现在顺序不同了。如果它们两个都是同步的（有时可能是，依程序执行的条件而定），现在顺序是`A -> C -> D -> F -> E -> B`。

似乎听到了成千上万的JS程序员一声轻微的叹息，他们刚刚以手掩面。

是嵌套的问题吗？是它让异步流追踪变得困难了吗？当然，部分是。

但让我们重写之前的嵌套事件/定时器/Ajax，不用嵌套：

```javascript
listen( "click", handler );

function handler() {
    setTimeout( request, 500 );
}

function request(){
    ajax( "http://some.url.1", response );
}

function response(text){
    if (text == "hello") {
        handler();
    }
    else if (text == "world") {
        request();
    }
}
```

相比于之前的嵌套/缩进，这种形式的代码并没有让辨识度变得更好，很容易受”地狱回调“的影响。为什么？

当序列化地解释这段代码时，我们不得不跳过一个又一个函数，围绕着基本代码来“看”序列流。记住，这只是最好情况下的简化代码。我们都知道真正的异步JS程序通常更复杂，使得解释这种规模代码的顺序变得更困难。

另一个要注意的是：为了将步骤2,3,4串联起来以便连续发生，回调函数给我们的唯一启示是将步骤2硬编码进步骤1，步骤3硬编码进步骤2，步骤4硬编码进步骤3，等等。硬编码并不一定是坏事，如果步骤2总是导致步骤3发生的话。

但硬编码肯定会使程序变得脆弱，因为它并不负责可能导致程序步骤运行偏差的错误。比如，如果步骤2失败了，则永远也不会运行到步骤3，更没有重试步骤2了，或者移到一个可选的错误处理流了，诸如此类。

所有这些问题你可以手动地编入到每一步当中去，但那样的代码通常非常重复，在程序的其它步骤或者异步流中难以复用。

尽管能够以序列化的方式（这样，然后这样，然后这样）计划一系列任务，我们的大脑










